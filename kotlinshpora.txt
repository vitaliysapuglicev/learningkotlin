план обучения котлин
1 - введение 
      среды разработки на Kotlin




2 - основы синтаксиса
      переменные / типы  данных / операторы
Для хранения данных в программе в Kotlin, как и в других языках программирования, применяются переменные. Переменная представляет именованный участок памяти, который хранит некоторое значение. Каждая переменная характеризуется определенным именем, типом данных и значением. Имя переменной представляет поизвольный идентификатор, который может содержать алфавитно-цифровые символы или символ подчеркивания и должен начинаться либо с алфавитного символа, либо со знака подчеркивания. Для определения переменной можно использовать либо ключевое слово val, либо ключевое слово var. 

VAL - Ключевое слово val (от слова value) ссылается на неизменяемую переменную, что соответствует ключевому слову final в Java. 

VAR - Для обычных изменяемых переменных используется ключевое слово var (от слова variable). Рекомендуется всегда использовать val, если это позволяет логика программы.

[val|var имя_переменной: тип_переменной]

Например, определим переменную age:

[var age: Int]

То есть в данном случае объявлена переменная age, которая имеет тип Int. Тип Int говорит о том, что переменная будет содержать целочисленные значения.После определения переменной ей можно присвоить значение:

[fun main() {
    var age: Int
    age = 23
    println(age) }]

Для присвоения значения переменной используется знак равно. Затем мы можем производить с переменной различные операции. Например, в данном случае с помощью функции println() значение переменной выводится на консоль. И при запуске этой программы на консоль будет выведено число 23. Присвоение значения переменной должно производиться только после ее объявления. И также мы можем сразу присвоить переменной начальное значение при ее объявлении. Такой прием называется инициализацией:

[fun main() {
    var age: Int = 23
    println(age) }]

Однако обязательно надо присвоить переменной некоторое значение до ее использования:

[fun main() {
    var age: Int
    println(age)// Ошибка, переменная не инициализирована
}]

Также Kotlin поддерживает константы времени компиляции. Для их определения применяются ключевые слова const val:

[const val maxAge = 120  // константа
fun main() {
    println(maxAge)}]

В данном случае maxAge является константой. Отличительной особенностью констант является то, что они на стадии компиляции должны иметь некоторое значение, и это значение изменить нельзя. Это накладывает на использование констант ряд ограничений:

-Естественно нельзя изменить значение константы.
-Константа должна объявляться на самом верхнем уровне (вне класса/функции).
-Тип данных константы должен соответствовать одному из примитивных (например, Int) или типу String.

Типы данных:

Целочисленные типы:

Byte: хранит целое число от -128 до 127 и занимает 1 байт
Short: хранит целое число от -32 768 до 32 767 и занимает 2 байта
Int: хранит целое число от -2 147 483 648 (-231) до 2 147 483 647 (231 - 1) и занимает 4 байта
Long: хранит целое число от –9 223 372 036 854 775 808 (-263) до 9 223 372 036 854 775 807 (263-1) и занимает 8 байт

Объекты целочисленных типов хранят целые числа:

[fun main(){

    val a: Byte = -10
    val b: Short = 45
    val c: Int = -250
    val d: Long = 30000
    println(a) // -10
    println(b) // 45
    println(c) // -250
    println(d) // 30000} ]

Числа с плавающей точкой:

Кроме целочисленных типов в Kotlin есть два типа для чисел с плавающей точкой, которые позволяют хранить дробные числа:

Float: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта.
Double: хранит число с плавающей точкой от ±5.0*10-324 до ±1.7*10308 и занимает 8 байта.

[val height: Double = 1.78
val pi: Float = 3.14F
println(height)      // 1.78
println(pi)         // 3.14]

Логический тип Boolean:

Тип Boolean может хранить одно из двух значений: true (истина) или false (ложь).

[val a: Boolean = true
val b: Boolean = false]

Символы:

Символьные данные представлены типом Char. Он представляет отдельный символ, который заключается в одинарные кавычки.

[val a: Char = 'A'
val b: Char = 'B'
val c: Char = 'T']

Строки:

Строки представлены типом String. Строка представляет последовательность символов, заключенную в двойные кавычки, либо в тройные двойные кавычки.

[fun main() {
    val name: String = "Eugene"
    println(name)}]


Шаблоны строк (string templates) представляют удобный способ вставки в строку различных значений, в частности, значений переменных.
Так, с помощью знака доллара $ мы можем вводить в строку значения различных переменных:

[fun main() {
    val firstName = "Tom"
    val lastName = "Smith"
    val welcome = "Hello, $firstName $lastName"
    println(welcome)    // Hello, Tom Smith}]

Операторы и специальные символы (Operators and Special Symbols):

Котлин поддерживает следующие операторы и специальные символы:
+, -, *, /, % - математические операторы
* также используется для передачи массива в параметр vararg
=
оператор присваивания
используется для указания значений по умолчанию для параметров
+=, -=, *=, /=, %= - расширенные операторы присваивания
++, -- - операторы инкремента и декремента
&&, ||, ! - логические операторы ‘и’, ‘или’, ‘не’ (для побитовых операций используют соответствующие инфиксные функции)
==, != - операторы равенства (переведенные на вызовы equals() для не-примитивных типов)
===, !== - операторы ссылочного равенства
<, >, <=, >= - операторы сравнения (переведенные на вызовы compareTo() для не-примитивных типов)
[, ] - оператор индексированного доступа (переведенный на вызовы get и set)
!! утверждает, что выражение не равно null
?. выполняет безопасный вызов (вызывает метод или обращается к свойству, если получатель не имеет значения null)
?: принимает правое значение, если левое значение равно нулю (Элвис оператор)
:: создает ссылку на элемент или ссылку на класс
.. создает диапазон
: отделяет имя от типа в объявлениях
? отмечает тип с нулевым значением
->
разделяет параметры и тело лямбда-выражения
разделяет параметры и тип возвращаемого значения при объявлении лямбды
разделяет условие и тело ветви выражения when
@
вводит аннотацию
вводит или ссылается на метку цикла
вводит или ссылается на лямбда-метку
ссылается на выражение ‘this’ из внешней области
ссылается на внешний суперкласс
; разделяет несколько операторов на одной строке
$ ссылается на переменную или выражение в строковом шаблоне
_
заменяет неиспользуемый параметр в лямбда выражении
заменяет неиспользуемый параметр в деструктуризирующем присваивании

3 - управляющие структуры
      If - when

Условное выражение if
В языке Kotlin if является выражением, т.е. оно возвращает значение. Это позволяет отказаться от тернарного оператора (условие ? условие истинно : условие ложно), потому что обычному if вполне по силам его заменить.

// обычное использование
var max = a
if (a < b) max = b

// с блоком else
var max: Int
if (a > b) {
    max = a
} else {
    max = b
}

// в виде выражения
val max = if (a > b) a else b
“Ветви” выражения if могут быть блоками, т.е. содержать несколько строк кода, при этом последнее выражение является значением блока:

val max = if (a > b) {
    print("возвращаем a")
    a
} else {
    print("возвращаем b")
    b
}
Если вы используете if в качестве выражения (например, возвращая его значение или присваивая его переменной), то использование ветки else является обязательным.

when определяет условное выражение с несколькими “ветвями”. Оно похоже на оператор switch, присутствующий в C-подобных языках.

when (x) {
    1 -> print("x == 1")
    2 -> print("x == 2")
    else -> { // обратите внимание на блок
        print("x не равен ни 1, ни 2")
    }
}
when последовательно сравнивает свой аргумент со всеми указанными значениями, пока не выполнится какое-либо из условий ветвей.

when можно использовать и как выражение, и как оператор. При использовании его в виде выражения значение первой ветки, удовлетворяющей условию, становится значением всего выражения. При использовании в виде оператора значения отдельных веток отбрасываются. В точности как if: каждая ветвь может быть блоком и её значением является значение последнего выражения блока.

Значение ветки else вычисляется в том случае, когда ни одно из условий в других ветках не удовлетворено.

Если when используется как выражение, то ветка else является обязательной, за исключением случаев, в которых компилятор может убедиться, что ветки покрывают все возможные значения. Так происходит, например с записями класса enum и с подтипами sealed (изолированных) классов.

enum class Bit {
  ZERO, ONE
}
val numericValue = when (getRandomBit()) {
    Bit.ZERO -> 0
    Bit.ONE -> 1
    // 'else' не требуется, потому что все случаи учтены
}
В операторах when ветка else является обязательной в следующих условиях:

when имеет объект типа Boolean, enum, sealed или их nullable-аналоги;
ветки when не охватывают все возможные случаи для этого объекта.
enum class Color {
    RED, GREEN, BLUE
}

when (getColor()) {
    Color.RED -> println("red")
    Color.GREEN -> println("green")
    Color.BLUE -> println("blue")
    // 'else' не требуется, потому что все случаи учтены
}

when (getColor()) {
    Color.RED -> println("red") // нет веток для GREEN и BLUE
    else -> println("not red") // 'else' обязателен
}
Если для нескольких значений выполняется одно и то же действие, то условия можно перечислять в одной ветке через запятую.

when (x) {
    0, 1 -> print("x == 0 or x == 1")
    else -> print("otherwise")
}
Помимо констант в ветках можно использовать произвольные выражения.

when (x) {
    s.toInt() -> print("s encodes x")
    else -> print("s does not encode x")
}
Также можно проверять вхождение аргумента в интервал in или !in или его наличие в коллекции:

when (x) {
    in 1..10 -> print("x is in the range")
    in validNumbers -> print("x is valid")
    !in 10..20 -> print("x is outside the range")
    else -> print("none of the above")
}
Помимо этого Kotlin позволяет с помощью is или !is проверить тип аргумента. Обратите внимание, что благодаря умным приведениям вы можете получить доступ к методам и свойствам типа без дополнительной проверки.

fun hasPrefix(x: Any) = when(x) {
    is String -> x.startsWith("prefix")
    else -> false
}
when удобно использовать вместо цепочки условий вида if-else if. При отсутствии аргумента условия работают как простые логические выражения, а тело ветки выполняется при его истинности.

when {
    x.isOdd() -> print("x is odd")
    y.isEven() -> print("y is even")
    else -> print("x+y is odd")
}
Можно получать переменную внутри when условия по следующему синтаксису:

fun Request.getBody() =
    when (val response = executeRequest()) {
        is Success -> response.body
        is HttpError -> throw HttpException(response.status)
    }
Такая переменная, объявленная внутри условия when может быть видна только внутри тела этого when.

      циклы - for - while (do-while)

Цикл for обеспечивает перебор всех значений, поставляемых итератором. Он эквивалентен циклу foreach в таких языках, как C#.

for (item in collection) print(item)
Телом цикла может быть блок кода.

for (item: Int in ints) {
    // ...
}
Как отмечено выше, цикл for позволяет проходить по всем элементам объекта, имеющего итератор, например:

обладающего внутренней или внешней функцией iterator(), возвращаемый тип которой Iterator<>:
обладает внутренней или внешней функцией next()
обладает внутренней или внешней функцией hasNext(), возвращающей Boolean.
Все три указанные функции должны быть объявлены как operator.

Чтобы перебрать диапазон чисел, используйте выражение диапазона:

for (i in 1..3) {
    println(i)
}
for (i in 6 downTo 0 step 2) {
    println(i)
}
Цикл for по диапазону или массиву компилируется в основанный на индексе цикл, который не создает объект итератора.

Если при проходе по массиву или списку необходим порядковый номер элемента, используйте следующий подход:

for (i in array.indices) {
    println(array[i])
}
Также вы можете использовать библиотечную функцию withIndex.

for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
}

Цикл while
Тело циклов while и do-while выполняется до тех пор, пока их условие выполняется. Разница между ними заключается во времени проверки условия:

while проверяет условие и, если оно истинно, выполняет тело, а затем возвращается к проверке условия;
do-while выполняет тело и только затем проверяет условие. Если оно выполняется, цикл повторяется. Таким образом, тело do-while выполняется по крайней мере один раз независимо от условия.
while (x > 0) {
    x--
}

do {
    val y = retrieveData()
} while (y != null) // y здесь доступно!







------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

4 - объектно ориентированное программирование
      классы и объекты

Для определения класса применяется ключевое слово class, после которого идет имя класса. А после имени класса в фигурных скобках определяется тело класса. Если класс не имеет тела, то фигурные скобки можно опустить. Например, определим класс, который представляет человека:

class Person
 
// либо можно так
class Person { }

Класс фактически представляет новый тип данных, поэтому мы можем определять переменные этого типа:

fun main() {
 
    val tom: Person
    val bob: Person
    val alice: Person
}
 
class Person
В функции main определены три переменных типа Person. Стоит также отметить, что в отличие от других объектно-ориентированных языков (как C# или Java), функция main в Kotlin не помещается в отдельный класс, а всегда определяется вне какого-либо класса.

Для создания объекта класса необходимо вызвать конструктор данного класса. Конструктор фактически представляет функцию, которая называется по имени класса и которая выполняет инициализацию объекта. По умолчанию для класса компилятор генерирует пустой конструктор, который мы можем использовать:


val tom: Person = Person()
Часть кода после знака равно Person() как раз и представляет вызов конструктора, который создает объект класса Person. До вызова конструктора переменная класса не указывает ни на какой объект.

Например, создадим три объекта класса Person:

fun main() {
 
    val tom: Person = Person()
    val bob: Person = Person()
    val alice: Person = Person()
}
 
class Person

Свойства
Каждый класс может хранить некоторые данные или состояние в виде свойств. Свойства представляют переменные, определенные на уровне класса с ключевыми словами val и var. Если свойство определено с помощью val, то значение такого свойства можно установить только один раз, то есть оно immutable. Если свойство определено с помощью var, то значение этого свойства можно многократно изменять.

Свойство должно быть инициализировано, то есть обязательно должно иметь начальное значение. Например, определим пару свойств:


class Person{
    var name: String = "Undefined"
    var age: Int = 18
}
В данном случае в классе Person, который представляет человека, определены свойства name (имя человека) и age (возраст человека). И эти свойства инициализированы начальными значениями.

Поскольку эти свойства определены с var, то мы можем изменить их начальные значения:

fun main() {
 
    val bob: Person = Person()  // создаем объект
    println(bob.name)       // Undefined
    println(bob.age)        // 18
 
    bob.name = "Bob"
    bob.age = 25
 
    println(bob.name)       // Bob
    println(bob.age)        // 25
}
 
class Person{
    var name: String = "Undefined"
    var age: Int = 18
}
Для обращения к свойствам используется имя переменной, которая предствляет объект, и после точки указывается имя свойства. Например, получение значения свойства:


val personName : String = bob.name
Установка значения свойства:


bob.name = "Bob"
Функции класса
Класс также может содержать функции. Функции определяют поведение объектов данного класса. Такие функции еще называют member functions или функции-члены класса. Например, определим класс с функциями:

class Person{
    var name: String = "Undefined"
    var age: Int = 18
 
    fun sayHello(){
        println("Hello, my name is $name")
    }
 
    fun go(location: String){
        println("$name goes to $location")
    }
 
    fun personToString() : String{
        return "Name: $name  Age: $age"
    }
}
Функции класса определяется также как и обычные функции. В частности, здесь в классе Person определена функция sayHello(), которая выводит на консоль строку "Hello" и эмулирует приветствие объекта Person. Вторая функция - go() эмулирует движение объекта Person к определенному местоположению. Местоположение передается через параметр location. И третья функция personToString() возвращает информацию о текущем объекте в виде строки.

В функциях, которые определены внутри класса, доступны свойства этого класса. Так, в данном случае в функциях можно обратиться к свойствам name и age, которые определены в классе Person.

Для обращения к функциям класса необходимо использовать имя объекта, после которого идет название функции и в скобках значения для параметров этой функции:

fun main() {
 
    val tom = Person()
    tom.name = "Tom"
    tom.age = 37
 
    tom.sayHello()
    tom.go("the shop")
    println(tom.personToString())
 
}
 
class Person{
    var name: String = "Undefined"
    var age: Int = 18
 
    fun sayHello(){
        println("Hello, my name is $name")
    }
 
    fun go(location: String){
        println("$name goes to $location")
    }
 
    fun personToString() : String{
        return "Name: $name  Age: $age"
    }
}










      наследование - интерфейсы - абстрактные классы





5 - функциональное программирование 
      лямбда выражения и коллекции 
      основные функции высшего порядка 





6 - основные библиотеки Kotlin
      Ktor - веб разработка 
      android sdk - мобильная разработка
